version: '3'

services:
  reverse-proxy:
    restart: on-failure
    # The official v2 Traefik docker image
    image: traefik:v2.6
    # Enables the web UI and tells Traefik to listen to docker
    hostname: reverse-proxy
    command:
      #- --api.insecure=true
      - --providers.docker=true
      #- --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --providers.file.directory=/configuration/
      - --providers.file.watch=true
    ports:
      - 80:80
      - 443:443
      # The Web UI (enabled by --api.insecure=true)
      #- 8080:8080
    volumes:
      # So that Traefik can listen to the Docker events
      - ./traefik/certs:/tools/certs
      - ./traefik/configuration:/configuration/
      - ${DOCKER_SOCKET}:${DOCKER_SOCKET}

  public-api:
    restart: always
    build:
      context: ./public_api/img/
      dockerfile: Dockerfile
    hostname: ${PUBLIC_API_HOST}
    command: uvicorn --host "0.0.0.0" --port ${PUBLIC_API_PORT} api:app
    env_file:
      - .env
    ports:
      - ${PUBLIC_API_PORT}
    labels:
      - "traefik.http.routers.${PROJECT_NAME}_${PUBLIC_API_HOST}.rule=Host(`omen.onerm.dk`)"
      - "traefik.http.services.${PROJECT_NAME}_${PUBLIC_API_HOST}.loadbalancer.server.port=${PUBLIC_API_PORT}"
      - "traefik.http.routers.${PROJECT_NAME}_${PUBLIC_API_HOST}.tls=${HTTPS_ON}"
    volumes:
     - ${LOGS_VOLUME}:${LOGGING_DIR}

  database:
    image: postgres:latest
    restart: on-failure
    hostname: ${DB_HOST}
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: ${DB_NAME}
    env_file:
      - .env
    volumes:
      - ${LOGS_VOLUME}:${LOGGING_DIR}
      - ${DB_VOLUME}:/var/lib/postgresql/data

  api:
    hostname: ${API_HOST}
    command: uvicorn --host "0.0.0.0" --port ${API_PORT} api:app
    restart: on-failure
    depends_on:
      - rabbit
      - database
    ports:
      - ${API_PORT}
    environment:
      - PYTHONUNBUFFERED=1
    env_file:
      - .env
    build:
      context: private_api/img/
      dockerfile: Dockerfile
    volumes:
     - ${DATA_VOLUME}:${DATA_DIR}
     - ${LOGS_VOLUME}:${LOGGING_DIR}
     - ${MODELS_VOLUME}:${MODELS_DIR}

  rabbit:
    restart: on-failure
    image: rabbitmq:latest
    ports:
      - 5672
    hostname: rabbit
    healthcheck:
      test: [ "CMD", "nc", "-z", "${RABBIT_HOST}", "5672" ]
      interval: 5s
      timeout: 15s
      retries: 1
      
  job-consumer:
    hostname: job_consumer
    restart: on-failure
    depends_on:
      - rabbit
      - api
    env_file:
      - .env
    build:
      context: ./job_consumer/img
      dockerfile: Dockerfile
    environment:
      - PYTHONUNBUFFERED=1
    volumes:
      # needed to dispatch docker containers from inside a docker container
      - ${DOCKER_SOCKET}:${DOCKER_SOCKET}
     # - ${LOGS_VOLUME}:${LOGGING_DIR}

#  model-repository:
#    depends_on:
#      - api
#      - database
#    build:
#      context: ./model_repository/
#      dockerfile: Dockerfile
#    environment:
#      - PYTHONUNBUFFERED=1
#    #volumes:
#      - ${DOCKER_SOCKET}:${DOCKER_SOCKET}
#      - $(realpath model_repository/models):/models
## Volumes must match names in .env!
volumes:
  db_storage:
  data_storage:
  models_storage:
  logs_storage:
